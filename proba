// A j√°t√©khoz haszn√°lt k√©pek t√∂mbje (minden k√©p egyedi azonos√≠t√≥val, p√°rokhoz duplik√°lva is lehet)
const images = [
    "kepek/macska.png",
    "kepek/bika.png",
    "kepek/mester.png",
    "kepek/halalfej.png",
    "kepek/paci.png",
    "kepek/bunny.png",
    "kepek/mehecske.png",
    "kepek/teki.png",
    "kepek/macska.png",
    "kepek/adrien.png",
    "kepek/katica.png",
    "kepek/marinette.png"
];

// A jelenleg felford√≠tott k√°rty√°kat tartalmaz√≥ t√∂mb (max 2 lehet benne egyszerre)
forditott_kartyak = [];
// Ha true, akkor a t√°bla z√°rolva van (nem lehet kattintani), pl. anim√°ci√≥k vagy ellen≈ërz√©s k√∂zben
let lockBoard = false;
// Megtal√°lt p√°rok sz√°ma
let talalt_parok = 0;
// Hib√°s pr√≥b√°lkoz√°sok sz√°ma (nem egyez≈ë p√°rok)
let hibas_parok = 0;
// Aktu√°lis neh√©zs√©gi szint (konnyu, kozepes, nehez)
let nehezseg = null;

// DOM elemek v√°ltoz√≥kba ment√©se a gyorsabb el√©r√©shez
const email = document.getElementById("email");
const age = document.getElementById("age");
const reg = document.getElementById("regist");
const szintek_gombok = document.getElementById("szintek");
const ul = document.querySelector("ul");
const h2 = document.querySelector("h2");
const stat = document.getElementById("stat")
const section = document.getElementById("jatekmezo")

const counterElement = document.getElementById("counter");
const timerElement = document.getElementById("timer");
const newgame = document.getElementById("newgame");

// Id≈ëm√©r√©shez sz√ºks√©ges v√°ltoz√≥k
let startTime;
// TIMER INTERVAL: Az id≈ëz√≠t≈ë azonos√≠t√≥ja, amivel k√©s≈ëbb le√°ll√≠thatjuk a sz√°ml√°l√≥t
let timerInterval;

// Szintv√°laszt√≥ gomb esem√©nykezel≈ëje
szintek_gombok.addEventListener("click", szintnev);

// Ez a f√ºggv√©ny kezeli, hogy melyik szintgomb lett kiv√°lasztva
function szintnev(e){
    const button = e.target;
    // Csak akkor fut le, ha t√©nyleg egy szintgombra kattintottak
    if (!button.matches(".szintgomb")) return;
    // ID vs SELECTED CLASS:
    // - Az ID (pl. "konnyu", "kozepes", "nehez") csak azonos√≠t√°sra szolg√°l, hogy tudjuk, melyik gomb volt kor√°bban kiv√°lasztva.
    // - A "selected" classList csak vizu√°lis kiemel√©sre szolg√°l, hogy a felhaszn√°l√≥ l√°ssa, melyik szint akt√≠v.
    // El≈ëz≈ëleg kiv√°lasztott szintr≈ël levessz√ºk a kijel√∂l√©st (ha volt m√°r)
    if (nehezseg) document.querySelector(`#${nehezseg}`).classList.remove("selected");
    // Az √∫j szint gombot kijel√∂lj√ºk (vizu√°lis kiemel√©s)
    button.classList.add("selected");
    // Be√°ll√≠tjuk az aktu√°lis neh√©zs√©get (az id alapj√°n tudjuk, melyik gomb volt az el≈ëz≈ë)
    nehezseg = button.id;
}

// Regisztr√°ci√≥s adatok ellen≈ërz√©se, √©s ha minden rendben, tov√°bbl√©p√©s a szintv√°laszt√°shoz
function szintvalasztas() {
    // trim() - elt√°vol√≠tja a sz√≥k√∂z√∂ket az email elej√©r≈ël √©s v√©g√©r≈ël, hogy ne lehessen v√©letlen√ºl √ºres karaktereket megadni
    const emailValue = email.value.trim();
    const ageValue = age.value;

    // Ellen≈ërzi, hogy mindk√©t mez≈ë ki van-e t√∂ltve
    if (!emailValue || !ageValue) {
        alert("K√©rlek t√∂ltsd ki mindk√©t mez≈ët!");
    }
    // Egyszer≈± email form√°tum ellen≈ërz√©s
    else if (!emailValue.includes('@') || !emailValue.includes('.')) {
        alert("Az email c√≠mnek tartalmaznia kell '@' √©s '.' karaktert!");
    } 
    // √âletkor ellen≈ërz√©se (1-99 k√∂z√∂tt)
    else if(ageValue<1 || ageValue > 99){
        alert("Hib√°s √©letkort adt√°l meg!");
    }
    // Ha minden ok√©, elrejti a regisztr√°ci√≥s mez≈ëket, megjelen√≠ti a szintv√°laszt√≥t
    else {
        email.hidden = true;
        age.hidden = true;
        szintek_gombok.hidden = false;
        reg.hidden = true;
        updateCounter();
        h2.style.display = "none";
    }
}

// Ez a f√ºggv√©ny gener√°lja le a j√°t√©kmez≈ët a kiv√°lasztott p√°rok sz√°m√°val
function general(pairsNeeded) {
    startTimer(); // Id≈ëz√≠t≈ë ind√≠t√°sa
    newgame.hidden = true;
    szintek_gombok.hidden = true;
    power.disabled = true;
    help.disabled = true;
    const ul = document.querySelector("ul");
    ul.innerHTML = ""; // J√°t√©kmez≈ë √ºr√≠t√©se
    updateCounter();

    // K√âPEK KIV√ÅLASZT√ÅSA: Az els≈ë 'pairsNeeded' sz√°m√∫ k√©pet v√°lasztja ki a j√°t√©khoz
    const selectedImages = images.slice(0, pairsNeeded);

    // K√ÅRTYAK√âZEL√âS: Duplik√°lja a k√©peket (p√°rokat hoz l√©tre), majd √∂sszekeveri ≈ëket
    // sort(() => Math.random() - 0.5): V√©letlenszer≈±en keveri a t√∂mb√∂t, hogy a p√°rok ne egym√°s mellett legyenek
    const gameCards = [...selectedImages, ...selectedImages]
        .sort(() => Math.random() - 0.5);

    // Minden k√°rty√°hoz l√©trehoz egy <li> elemet, be√°ll√≠tja a k√©pet, esem√©nykezel≈ët ad hozz√°
    gameCards.forEach((img, index) => {
        const li = document.createElement('li');
        // DATASET.VALUE: A k√°rtya egyedi azonos√≠t√≥ja (a k√©p el√©r√©si √∫tja), ezt haszn√°ljuk a p√°ros√≠t√°s ellen≈ërz√©s√©hez
        li.dataset.value = img;
        li.innerHTML = `
            <div class="card-front"></div>
            <div class="card-back"><img src="${img}" alt="K√©p"></div>
        `;
        li.addEventListener('click', flipCard);
        ul.appendChild(li);
    });
    
    document.querySelector("section").hidden = false;
    const allCards = document.querySelectorAll("li");
    // J√°t√©k elej√©n minden k√°rty√°t felford√≠t r√∂vid id≈ëre, hogy a j√°t√©kos megjegyezhesse
    allCards.forEach(card => card.classList.add("flipped"));
    // SETTIMEOUT: 2000ms = 2 m√°sodpercig l√°tszanak a k√°rty√°k, ut√°na visszafordulnak
    // A setTimeout els≈ë param√©tere egy f√ºggv√©ny, amit a m√°sodik param√©terben megadott id≈ë (ezredm√°sodperc) m√∫lva futtat le
    setTimeout(() => {
        allCards.forEach(card => card.classList.remove("flipped"));
        lockBoard = false;
        power.disabled = false;
        help.disabled = false;
    }, 2000);
    lockBoard = true; // K√°rty√°k z√°rol√°sa, am√≠g felford√≠tva vannak
    power.hidden = false;
    help.hidden = false;
}

// K√°rtya felford√≠t√°sa kattint√°sra
function flipCard() {
    // Ha a t√°bla z√°rolva van, vagy m√°r fel van ford√≠tva a k√°rtya, kil√©p
    if (lockBoard || this.classList.contains('flipped')) return;
    
    this.classList.add('flipped');
    forditott_kartyak.push(this); // Hozz√°adja a felford√≠tott k√°rty√°khoz
    
    // Ha k√©t k√°rtya van felford√≠tva, ellen≈ërzi, hogy p√°rt alkotnak-e
    if (forditott_kartyak.length === 2) {
        checkMatch();
    }
}

// Ellen≈ërzi, hogy a k√©t felford√≠tott k√°rtya egyezik-e
function checkMatch() {
    lockBoard = true; // Z√°rolja a t√°bl√°t, am√≠g az ellen≈ërz√©s tart
    const [card1, card2] = forditott_kartyak;
    // card1.dataset.value: a k√°rtya egyedi azonos√≠t√≥ja (k√©p el√©r√©si √∫tja), √≠gy lehet ellen≈ërizni, hogy egy p√°rt alkotnak-e
    if (card1.dataset.value === card2.dataset.value) {
        handleMatch(); // Ha egyeznek, p√°ros√≠t√°s kezel√©se
    } else {
        hibas_parok++;
        updateCounter();
        unflipCards(); // Ha nem egyeznek, visszaford√≠tja ≈ëket
    }
}

// Ha p√°ros√≠tottunk k√©t k√°rty√°t, elt√ºnteti ≈ëket √©s n√∂veli a sz√°ml√°l√≥t
function handleMatch() {
    talalt_parok++;
    updateCounter();
    
    // SETTIMEOUT: 800ms = 0.8 m√°sodpercig l√°tszanak m√©g a p√°ros√≠tott k√°rty√°k, hogy a j√°t√©kos l√°ssa a tal√°latot
    setTimeout(() => {
        forditott_kartyak.forEach(card => {
            card.style.opacity = '0'; // K√°rtya elt√ºntet√©se (l√°thatatlan lesz)
            // POINTER EVENTS: Letiltja a kattint√°st a m√°r megtal√°lt k√°rty√°kra
            card.style.pointerEvents = 'none';
        });

        forditott_kartyak = [];
        lockBoard = false;
        // Ellen≈ërzi, hogy minden p√°rt megtal√°ltunk-e (j√°t√©k v√©ge)
        if (talalt_parok === document.querySelectorAll('li').length / 2) {
            // SETTIMEOUT: 500ms = 0.5 m√°sodperc m√∫lva jelenik meg a nyerem√©ny√ºzenet, hogy legyen ideje elt≈±nni az utols√≥ p√°rnak is
            setTimeout(() => 
                {
                    // ALERT: Egyszer≈± felugr√≥ ablak, ami √ºzenetet jelen√≠t meg a felhaszn√°l√≥nak
                    alert('Gratul√°lok, nyert√©l! üéâ'); 
                    stopTimer(); 
                    newgame.hidden=false;
                    power.hidden=true;
                    help.hidden=true;
                    section.hidden = true;
                    helyimentes(); // Eredm√©ny ment√©se helyileg
                    publikusmentes(); // Eredm√©ny ment√©se szerverre
                }, 500);
        }
    }, 800); // Kis k√©sleltet√©s, hogy l√°that√≥ legyen a p√°ros√≠t√°s
}

// Eredm√©ny ment√©se szerverre (publikus statisztika)
async function publikusmentes(){
    const pubdata = {
        email: email.value,
        age: age.value,
        szint: nehezseg,
        jatekido: parseInt(jatekIdo()),
        hiba: hibas_parok,
    }
    const OPTIONS = {
        method: "POST",
        body: JSON.stringify(pubdata)
    };
    const response = await fetch(`http://localhost/memory/create/`, OPTIONS);
    const data = await response.json();
}

// Eredm√©ny ment√©se a b√∂ng√©sz≈ë localStorage-ba (helyi statisztika)
function helyimentes(){
    let datas = JSON.parse(localStorage.getItem("datas"));
    const mainap = new Date();
    const data = {
        email: email.value,
        age: age.value,
        szint: nehezseg,
        jatekido: parseInt(jatekIdo()),
        hiba: hibas_parok,
        datum: `${mainap.getFullYear()}-${mainap.getMonth()}-${mainap.getDay()}`
    };
    datas.push(data);
    localStorage.setItem("datas", JSON.stringify(datas));
}

// Visszaadja az eltelt j√°t√©kid≈ët m√°sodpercben
function jatekIdo(){
    // Date.now() ezredm√°sodpercben adja vissza az id≈ët, ez√©rt el kell osztani 1000-rel, hogy m√°sodpercet kapjunk
    // P√©ld√°ul: 165000 ms => 165 m√°sodperc => 2 perc 45 m√°sodperc
    return Math.floor((Date.now() - startTime) / 1000).toString();
}

// Ha k√©t k√°rtya nem egyezett, visszaford√≠tja ≈ëket kis k√©sleltet√©ssel
function unflipCards() {
    // SETTIMEOUT: 1000ms = 1 m√°sodperc m√∫lva ford√≠tja vissza a hib√°s k√°rty√°kat
    setTimeout(() => {
        forditott_kartyak.forEach(card => card.classList.remove('flipped'));
        forditott_kartyak = [];
        lockBoard = false;
    }, 1000);
}

// Id≈ëz√≠t≈ë ind√≠t√°sa (j√°t√©k kezdet√©n)
function startTimer() {
    stopTimer(); // El≈ëz≈ë id≈ëz√≠t≈ë le√°ll√≠t√°sa, ha volt
    startTime = Date.now();
    timerElement.hidden = false;
    // TIMER INTERVAL: Az id≈ëz√≠t≈ë azonos√≠t√≥ja, amivel k√©s≈ëbb le√°ll√≠thatjuk a sz√°ml√°l√≥t
    timerInterval = setInterval(updateTimer, 1000); // 1 m√°sodpercenk√©nt friss√≠t
    counterElement.hidden = false;
    updateTimer();
}

// Id≈ëz√≠t≈ë kijelz≈ë friss√≠t√©se (perc:m√°sodperc form√°tum)
function updateTimer() {
    // ID≈êSZ√ÅM√çT√ÅS: Date.now() ezredm√°sodpercben adja vissza az id≈ët, /1000 m√°sodpercre konvert√°l
    const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
    const minutes = Math.floor(elapsedTime / 60);
    const seconds = elapsedTime % 60;
    timerElement.textContent = `Id≈ë: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
}

// Id≈ëz√≠t≈ë le√°ll√≠t√°sa, kijelz≈ë null√°z√°sa
function stopTimer() {
    clearInterval(timerInterval);
    timerElement.textContent = "Id≈ë: 0:00";
    timerElement.hidden = true;
    talalt_parok = 0;
    hibas_parok = 0;
    counterElement.hidden = true;
}

// P√°rok √©s hib√°k sz√°ml√°l√≥j√°nak friss√≠t√©se
function updateCounter() {
    counterElement.textContent = `Tal√°lt p√°rok: ${talalt_parok} | Hib√°s pr√≥b√°lkoz√°sok: ${hibas_parok}`;
    counterElement.hidden = false;
}

// J√°t√©k vissza√°ll√≠t√°sa kezd≈ë √°llapotba (√∫j j√°t√©k ind√≠t√°s√°hoz)
function reset() {
    email.hidden = false;
    age.hidden = false;
    reg.hidden = false;
    szintek_gombok.hidden = true;
    newgame.hidden = true;
    counterElement.hidden = true;
    document.querySelector("section").hidden = true;
    stopTimer();
    power.hidden = true;
    help.hidden = true;
}

// Oldal bet√∂lt√©sekor esem√©nykezel≈ëk be√°ll√≠t√°sa
document.addEventListener("DOMContentLoaded", () => {
    reg.addEventListener("click", szintvalasztas);
    document.getElementById("konnyu").addEventListener("click", () => general(6)); // 6 p√°r
    document.getElementById("kozepes").addEventListener("click", () => general(8)); // 8 p√°r
    document.getElementById("nehez").addEventListener("click", () => general(12)); // 12 p√°r
    newgame.addEventListener("click", reset);
});

// Statisztika oldalra ugr√°s gombnyom√°sra
stat.addEventListener("click", () => window.location.href = "statisztika_weboldal/index.html");

// "K√°rty√°k felfed√©se" powerup: minden leford√≠tott k√°rty√°t 3 m√°sodpercre felford√≠t
power.addEventListener("click", () => {
    power.disabled = true;
    const allCards = document.querySelectorAll("li:not(.flipped)");
    allCards.forEach(card => card.classList.add("flipped"));
    // SETTIMEOUT: 3000ms = 3 m√°sodpercig l√°tszanak a k√°rty√°k, majd visszafordulnak
    setTimeout(() => {
        allCards.forEach(card => card.classList.remove("flipped"));
    }, 3000);
});

// "Random p√°r elt√ºntet√©se" powerup: v√©letlenszer≈±en kiv√°laszt egy m√©g nem megtal√°lt p√°rt, √©s elt√ºnteti
help.addEventListener("click", () => {
    help.disabled = true;
    // FILTER LOGIKA: Csak azokat a k√°rty√°kat v√°lasztja ki, amelyek:
    // 1. Nincsenek felford√≠tva (:not(.flipped))
    // 2. L√°that√≥ak (opacity nem 0)
    const allCards = Array.from(document.querySelectorAll("li:not(.flipped)"))
        .filter(card => card.style.opacity !== "0");
    
    const pairsMap = {};

    // P√°rok csoportos√≠t√°sa azonos√≠t√≥ alapj√°n
    allCards.forEach(card => {
        const value = card.dataset.value;
        if (!pairsMap[value]) {
            pairsMap[value] = [card];
        } else {
            pairsMap[value].push(card);
        }
    });

    // Csak azokat vessz√ºk, ahol t√©nyleg 2 k√°rtya van (teh√°t m√©g nem t≈±nt el a p√°r)
    const pairs = Object.values(pairsMap).filter(pair => pair.length === 2);
    if (pairs.length === 0) return;

    // V√©letlenszer≈±en kiv√°laszt egy p√°rt
    const randomPair = pairs[Math.floor(Math.random() * pairs.length)];
    const [card1, card2] = randomPair;

    // Felford√≠tja ≈ëket, majd elt√ºnteti (mintha megtal√°ltuk volna)
    card1.classList.add("flipped");
    card2.classList.add("flipped");

    // SETTIMEOUT: 1500ms = 1,5 m√°sodpercig l√°tszik a random p√°r, majd elt≈±nik
    setTimeout(() => {
        card1.style.opacity = "0";
        card2.style.opacity = "0";
        card1.style.pointerEvents = "none";
        card2.style.pointerEvents = "none";
        talalt_parok++;
        updateCounter();
    }, 1500);
});


// TIMER INTERVAL: Az id≈ëz√≠t≈ë azonos√≠t√≥ja, amivel k√©s≈ëbb le√°ll√≠thatjuk a sz√°ml√°l√≥t
let timerInterval;

// K√âPEK KIV√ÅLASZT√ÅSA: Az els≈ë 'pairsNeeded' sz√°m√∫ k√©pet v√°lasztja ki a j√°t√©khoz
const selectedImages = images.slice(0, pairsNeeded);

// K√ÅRTYAK√âZEL√âS: Duplik√°lja a k√©peket (p√°rokat hoz l√©tre), majd √∂sszekeveri ≈ëket
const gameCards = [...selectedImages, ...selectedImages]
    .sort(() => Math.random() - 0.5); // Math.random()-0.5 v√©letlenszer≈± rendez√©st eredm√©nyez (-0.5 √©s 0.5 k√∂z√∂tti √©rt√©k)

// SETTIMEOUT: K√©sleltetett m≈±velet v√©grehajt√°sa (pl. anim√°ci√≥khoz). A sz√°m az ezredm√°sodpercben megadott k√©sleltet√©s.
// Pl. setTimeout(..., 500) = 500ms (0.5 m√°sodperc) k√©sleltet√©s
setTimeout(() => {
  // K√≥d ami 500ms ut√°n fut le
}, 500);

// DATASET.VALUE: A k√°rty√°hoz t√°rolt egyedi azonos√≠t√≥ (k√©p el√©r√©si √∫tja)
if (card1.dataset.value === card2.dataset.value) {
  // P√°ros√≠t√°s logik√°ja
}

// POINTER EVENTS: Eg√©rkattint√°sok letilt√°sa egy elemn√©l (pl. m√°r megtal√°lt k√°rty√°kn√°l)
card.style.pointerEvents = 'none'; // Letiltja a kattint√°st
card.style.pointerEvents = 'auto'; // √öjra enged√©lyezi

// ID≈êSZ√ÅM√çT√ÅS: Date.now() ezredm√°sodpercben adja vissza az id≈ët, /1000 m√°sodpercre konvert√°l
const elapsedTime = Math.floor((Date.now() - startTime) / 1000); 
// P√©ld√°ul: 165000 ms => 165 m√°sodperc => 2 perc 45 m√°sodperc

// FILTER LOGIKA: Csak azokat a k√°rty√°kat v√°lasztja ki, amelyek:
// 1. Nincsenek felford√≠tva (:not(.flipped))
// 2. L√°that√≥ak (opacity nem 0)
const allCards = Array.from(document.querySelectorAll("li:not(.flipped)"))
    .filter(card => card.style.opacity !== "0");

// ID vs SELECTED CLASS (El≈ëz≈ë k√©rd√©s magyar√°zata):
// - Az ID egyedi azonos√≠t√≥ a gombokhoz (pl. neh√©zs√©gi szintekhez)
// - A 'selected' CSS oszt√°ly vizu√°lis kiemel√©st biztos√≠t a kiv√°lasztott gombnak
document.querySelector(`#${nehezseg}`).classList.remove("selected"); // Elt√°vol√≠tja a kor√°bbi kijel√∂l√©st
button.classList.add("selected"); // √öj kijel√∂l√©s hozz√°ad√°sa
